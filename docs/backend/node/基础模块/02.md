---
title: "Node.js 模块加载导出"
date: 2020-01-17
sidebar: 'auto'
categories:
- BackEnd
tags:
- node基础模块
---






# 模块的加载导出

在`node.js`中每一的`JavaScript`文件就是一个文件作用域，文件之间的数据不可相互调用。

若某一文件要使用另一文件的某一数据，那么该文件就必须将要求的数据暴露出来。使用`module.exports` 或者`exports` 



假定`a.js`与`b.js`在同一根目录下

` a.js `文件

```javascript
const add = (a,b) => a+b
module.exports = {
    "add": add
}

//也可写成
module.exports.add = add

//或者
exports.add = add
```



`b.js`文件

```javascript
const a = require('./a')
console.log(a.add(1,3))
//结果4
```

`a.js` 将 其中的`add`方法通过挂载到`module.exports`上供 `b.js`调用

::: tip 疑问

既然`module.exports.add = add`与`exports.add = add`都可以满足向外暴露数据的要求，为什么还并存？

`module.exports `和 `exports `联系，以及应该 注意些什么 ？

:::

## `exports` 与 `module.exports` 的联系

* 早期使用 `module.exports` 来向外部暴露文件内部数据，`module.exports`太长写起来不方便，于是就催生了`exports`
* 实际上初始状态下`exports` 和`module.exports` 指向同一对象，`exports` 就相当属于 `module.exports`的别名
* 最终文件暴露出去的数据以`module.exports` 为准

## 使用注意

* 避免在同一文件中同时使用这两种方式（容易引起混淆）

```javascript
const b = 12
const add = a => a+=1

module.exports.b = b
exports.add = add
```

* 最好不要直接给`exports`,`module.exports`赋值

二者指向同一对象，如果其中一个重新赋值，那么`exports` 与`module.exports`之间的联系就会被切断，容易出错

```javascript
const b = 12
const add = a => a+=1

//重新赋值后 与 exports 指向了不同的对象
module.exports = add

//exports任然指着原来的对象，只是在原来的对象上添加了一个属性
exports.b = b
```

这时` exports` 再添加属性就不再起作用（因为最后向外暴露的值以`module.exports`所指对象为准）除非重新建立 `exports`与`module.exports`之间的联系

```
exports = module.exports
```

**总的来说就单一使用exports就好**


# 模块加载机制

## 查找规则

### 当模块拥有路径但没有后缀时

```javascript
require('./find.js');
```

```javascript
require('./find');
```

* `require`方法根据模块路径查找模块，如果是完整路径，直接引入模块。
* 如果模块后缀省略，先找同名JS文件再找同名`JS`文件夹
* 如果找到了同名文件夹，找文件夹中的`index.js`
* 如果文件夹中没有`index.js`就会去当前文件夹中的`package.json`件中查找`main`选项中的入口文件
* 如果找指定的入口文件不存在或者没有指定入口文件就会报错，模块没有被找到



### 当模块没有路径且没有后缀时

```javascript
require('find');
```

* `Node.js`会假设它是系统模块
* `Node.js`会去`node_modules`文件夹中
* 首先看是否有该名字的`JS`文件
* 再看是否有该名字的文件夹
* 如果是文件夹看里面是否有`index.js`
* 如果没有`index.js`查看该文件夹中的`package.json`中的`main`选项确定模块入口文件
* 否则找不到报错



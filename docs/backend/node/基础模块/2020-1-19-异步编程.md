---
title: "异步编程"
date: 2020-01-19
sidebar: 'auto'
categories:
- BackEnd
tags:
- node基础模块
---





# 异步编程

## 同步API 
> 只有当前API执行完成后，才能继续执行下一个API  


```javascript
console.log('1')
console.log('2')
```

可以从API中直接拿到返回值

```javascript
function sum (n1, n2) {
    return n1 + n2
}
const result = sum(10, 20)
//得到30
```



## 异步API

> 当前API执行不会阻塞后面的API执行

```javascript
console.log('before')
setTimeout(()=>{
    console.log('last')
},2000)
console.log('after')
/*
before
after
last
* /
```

不可以直接从API中获取返回值

```javascript
function getmsg() {
    setTimeout(()=>{
        return { 'msg': 'this is msg' }
    }, 2000)
}
const msg = getmsg()
console.log(msg)
//undefined 
```


### 回调函数

通过回调函数得到返回值

```javascript
function getData (callback){
    setTimeout(()=>{
        let a = 2
        //异步操作结束后，调用callback，把a传递出去
        callback(a)
    },2000)
}

getData( a =>{
    console.log(a)
    //得到a的值接下来对a进行其他操作
    //...
})
```



## 异步与同步的区别 （代码执行顺序）

* 同步API从上到下依次执行，前面的代码会阻塞后面的代码
```javascript
for (var i = 0; i < 100000; i++) { 
    console.log(i);
}
console.log('for循环后面的代码');
//循环没有结束前，最后一句永远不会执行
```

* 异步API不会等待API执行完成后再向下执行代码
```javascript
console.log('代码开始执行');
setTimeout(() => {
    console.log('2秒后执行的代码')
}, 2000);
setTimeout(() => {
    console.log('"0秒"后执行的代码')
}, 0);
console.log('代码结束执行')

/* 结果
代码开始执行
代码结束执行
"0秒"后执行的代码
2秒后执行的代码
*/
```

执行顺序详解图

<img src="/img/async.PNG">



## Node.js 中的异步API

* 文件读取
```javascript
fs.readFile('./demo.txt', (err, result) => {});
```
* 事件监听
```javascript
 var server = http.createServer();
 server.on('request', (req, res) => {});
```
::: tip 注意
如果异步API后面代码的执行依赖当前异步API的执行结果，但实际上后续代码在执行的时候异步API还没有返回结果，这个问题就需要用之前提到的回调函数来解决。
:::

* 等等 ... (Node中的异步API 多的数不胜数)

  

### 回调地狱

> 需求：依次读取A文件、B文件、C文件

实现代码
```javascript
const fs = require('fs')
fs.readFile('./1.async.js','utf8', (err, data) => {
    console.log('第一步完成')
    console.log(data)
    fs.readFile('./2.async.js', 'utf8', (err, data) => {
        console.log('第二步完成')
        console.log(data)
        fs.readFile('./3.callback.js','utf8',  (err, data) => {
            console.log('第三步完成')
            console.log(data)
            return
        })
    })
})
```
可见三层回调函数就如此繁琐，若更多层回调，代码将会变得不可维护。由此催生了promise



## Promise

> Promise出现的目的是解决Node.js异步编程中回调地狱的问题。promise 实际上一个构造函数

### 使用方式

```javascript
let promise = new Promise((resolve, reject) => {
    setTimeout(() => {
        if (true) {
            resolve({name: '张三'})//将异步api执行的结果，通过传递给resolve()函数 把结果传出去
        }else {
            reject('失败了') //同理
        } 
    }, 2000);
});
promise.then(result => console.log(result); // {name: '张三'})
       .catch(error => console.log(error); // 失败了)
```

```javascript
const fs = require('fs')

let promise = new Promise((resolve, reject) => {
    fs.readFile('./1.asnc.js', 'utf-8', (err, data) => {
        if (err) {
            reject(err)
            return
        }
        resolve(data)
    })
})

promise.then(result => console.log(result))
    .catch(err => console.log(err))
```



### 解决回调地狱

> 以前面的例子为改造对象

```javascript
const fs = require('fs')
let p1 = () => {
    return new Promise((resolve, reject) => {
        fs.readFile('./1.async.js', 'utf-8', (err, data) => {
            if (err) {
                reject(err)
                return
            }
            resolve(data)
        })
    })
}

let p2 = () => {
    return new Promise((resolve, reject) => {
        fs.readFile('./2.async.js', 'utf-8', (err, data) => {
            if (err) {
                reject(err)
                return
            }
            resolve(data)
        })
    })
}

let p3 = () => {
    return new Promise((resolve, reject) => {
        fs.readFile('./3.callback.js', 'utf-8', (err, data) => {
            if (err) {
                reject(err)
                return
            }
            resolve(data)
        })
    })
}

p1()
    .then(
        (result) => {
            console.log(result)
            return p2()
        }
    ).then((result) => {
        console.log(result)
        return p3()
    }).then((result) => {
        console.log(result)
    }).catch((err) => console.log(err))

```

::: warning 链式编程原则

在前一个`then`最后一行`return` 出想要执行的异步操作函数，那么下一个`then`的方式得到的就是该异步操作的`promise`对象

:::



## 异步函数

> 异步函数是异步编程语法的终极解决方案，它可以让我们将异步代码写成同步的形式，让代码不再有回调函数嵌套，使代码变得清晰明了。

### 基本形式

```javascript
const fn = async () => {}
async function fn () {}
```

### async关键字

* 普通函数定义前加`async`关键字 普通函数变成异步函数
*  异步函数默认返回`promise`对象

```javascript
async function fun (){}
console.log(fun())
//Promise { undefined }
```

*  在异步函数内部使用`return`关键字进行结果返回 结果会被包裹的`promise`对象中 `return`关键字代替了`resolve`方法

```javascript
const fun = async () => 123 //通过return 达到了与 resolve 一样的作用
fun().then((result) => {
    console.log(result)
})
//123
```

*  在异步函数内部使用`throw`关键字抛出程序异常

* 调用异步函数再链式调用`catch`方法获取异步函数执行的错误信息

```javascript
const fun = async () => {
    throw 'error !'
    return 123
}

fun().then((result) => {
    console.log(result)
}).catch((err) => console.log(err))
```

* 调用异步函数再链式调用`then`方法获取异步函数执行结果



### await 关键字

* `await`关键字只能出现在异步函数中
* `await promise await`后面只能写`promise`对象 写其他类型的API是不不可以的
* `await`关键字可以暂停异步函数向下执行 直到`promise`返回结果



简单例子

```javascript
let p1 = async ()=>{
    return 1
}

let p2 = async ()=>{
    return 2
}

let p3 = async ()=>{
    return 3
}

let run = async () => {
    let r1 = await p1()
    let r2 = await p2()
    let r3 = await p3()

    console.log(r1)
    console.log(r2)
    console.log(r3)
}

run()
```



文件读取例子

```javascript
const fs = require('fs')
//改造现有异步函数api 让其返回promise 对象 从而支持异步函数语法
const promisify = require('util').promisify
//调用promisify 方法改造现有异步api
const readFile = promisify(fs.readFile)


let run = async () => {
   let r1 = await readFile('./1.async.js','utf8')
   let r2 = await readFile('./2.async.js','utf8')
   let r3 = await readFile('./3.callback.js','utf8')

   console.log(r1)
   console.log(r2)
   console.log(r3)
}

run()
```

::: tip 注意

本来Node中的函数，不支持异步函数特性，但是通过`util`模块提供的`promisify`方法可以让不支持异步函数特性的函数具备与异步函数一样的特性。向`promisify`函数提供要改造的函数名称作为参数，并返回一个改造好的异步函数。

:::
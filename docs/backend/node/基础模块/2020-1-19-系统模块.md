---
title: "Node系统模块"
date: 2020-01-19
sidebar: 'auto'
categories:
- BackEnd
tags:
- node基础模块
---






# Node系统模块

> Node 运行环境所提供的API，因为这些API都是以模块化的方式开发的，所以我梦又称Node运行环境提供的API为系统模块



## fs 文件模块

> fs  :  file  system 文件系统

<img src="/img/fs.png">

### 读取文件

`fs,readFile(参数一，[参数二]，参数三)`

参数一：文件路径

参数二：文件编码，可选参数

参数三：回调函数，文件按读取完成后要做的事情，回调函数被传入了两个参数`error`，和`data`

如果文件读取成功：`error = null` ，`data `为读取的文件数据

如果文件读取失败：`error` 为错误对象，`data`为`null`

示例

```javascript
const fs = require('fs')

fs.readFile('./text/example.txt','utf-8',(err, data)=>{
    if(err){
        console.log('文件读取失败！')
        return
    }
    console.log(data)
})

/* 
第二个参数可以不传入，得到的结果为
<Buffer 63 6f 6e 73 6f 6c 65 2e 6c 6f 67 28 27 62 65 66 6f 72 65 27 29 0d 0a 73 65 74 54 69 6d 65 6f 75 74 28 28 29 20 3d 3e 20 7b 0d 0a 20 20 20 20 63 6f 6e ... 58 more bytes>
是一个十六进制串
解决方法：
1. 加上第二个参数 utf-8
2. 对最后的data使用toString()方法后得到可读的字符串

*/
```



### 写文件

`fs.writeFile(参数一, 参数二, 参数三)`

参数一：文件路径/文件名称

参数二：写入的数据

参数三：回调函数函数

示例

```javascript
 const content = '<h3>正在使用fs.writeFile写入文件内容</h3>';
 fs.writeFile('../index.html', content, err => {
   if (err) { 
       console.log(err);
       return;
   }
   console.log('文件写入成功');
 });

```



## Path 路径操作

### 路径拼接

由于不同操作系统路径分隔符不一样

Windows 上为 / 或 \

linux 上为 /

路径拼接语法

```javascrip
path.join('路径'，'路径',...)
```

```javascript
// 导入path模块
 const path = require('path');
  // 路径拼接
 let finialPath = path.join('\itcast', '\a', '\b', '\c.css')
  
 console.log(finialPath)
// 输出结果 itcast\a\b\c.css
```



### 相对路径&绝对路径

`require`方法可以用相对路径，相对的就是当前目录

`fs.readFile()`相对的基路径是当前命令行工具所在目录的路径，命令行路径改变，`fs.readFile()`的相对路径的基路径就会改变，容易出错，所以用绝对路径，使用`__dirname`获取当前文件的绝对路径。

::: wraing

大多数情况下使用绝对路径，因为相对路径有时候相对的是命令行工具的当前工作目录
在读取文件或者设置文件路径时都会选择绝对路径

:::



## URL 模块

> `url` 模块用于处理与解析 URL

### `url.prese(参数一,参数二,参数三)`

参数一：`<string>` 要解析的url字符串

参数二：`<boolean>` 如果为 `true`那么`query`字段将会被`querystring`模块的`parse`方法转换成一个对象，反之   				不会

参数三：`<boolean>` 如果为 `true`，则 `//` 之后至下一个 `/` 之前的字符串会被解析作为 `host`。 例如，`//foo/bar` 会被解析为 `{host: 'foo', pathname: '/bar'}` 而不是 `{pathname: '//foo/bar'}`。 默认为 `false`。

示例

```javascript
const url = require('url')

let myURL = url.parse('http://www.baicdu.com/about/next?name=leo&pass=123')
consloe.log(myURL)
```

得到结果

<img src="/img/url.parse.jpg">



```javascript
const url = require('url')

let myURL = url.parse('http://www.baicdu.com/about/next?name=leo&pass=123',true)

console.log(myURL)
```

得到结果

<img src="/img/url2.jpg">

可见`query`属性的值已经变成一个对象

```javascript
const url = require('url')

let myURL = url.parse('//www.baicdu.com/about/next?name=leo&pass=123',true,true)

console.log(myURL)
```

得到结果

<img src="/img/tt.jpg">

将`//`之后到下一个`/`之间的部分作为了`host`的值



## WHATWG URL

### URL 类

浏览器兼容的 `URL` 类，根据 WHATWG URL 标准实现。

::: warning 注意

根据浏览器的约定， `URL` 对象的所有属性都是在类的原型上实现为getter和setter，而不是作为对象本身的数据属性。因此，与[遗留的`urlObjects`不同，在 `URL` 对象的任何属性(例如 `delete myURL.protocol`， `delete myURL.pathname`等)上使用 `delete` 关键字没有任何效果，但仍返回 `true`。

:::

```javascript
const myURL = new URL('http://www.baicdu.com/about/next?name=leo&pass=123')
console.log(myURL)
```

得到结果

<img src="/img/url3.png">

通过

`for(let p of myURL.searchParams) `来获取 查询数据

```javascript
const myURL = new URL('http://www.baicdu.com/about/next?name=leo&pass=123')


for (let p of myURL.searchParams) {
    console.log(p)
}
/*
结果：
['name':'leo']
['pass':'123']
*/
```


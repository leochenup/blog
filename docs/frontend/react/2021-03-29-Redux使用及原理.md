---
title: "Redux 使用及原理"
date: 2021-03-29
sidebar: 'auto'
categories:
- FrontEnd
tags:
- React
---



## 工作流

<img src="https://my-blog-leo.oss-cn-chengdu.aliyuncs.com/redux%E5%B7%A5%E4%BD%9C%E6%B5%81.png"  />



> Redux 中 只有一个 `state` 树，存在以唯一的一个 `store`。

## 核心概念

### store

store 是状态数用来保存数据，它的常用的三个属性及方法 `dispatch` ,`getState` ,`subscribe`。

`dispatch(action)` 方法接收一个 `action` 用来作为处理数据的类型，它返回传入的 `action` ，初始化时会自动执行一次。

`getState()` 方法返回状态数据。

`subscribe(func)=>fun` 方法接收一个函数，当数据更新后，传入的函数就会被自动执行。此函数返回一个 `unsubscribe` 函数，他用来解绑传入的函数，此后数据更新，一开始传入的函数将不再执行。

<!-- more -->

### reducer

`reducer(state, action)` 函数接收两个参数，参数一是状态，参数二是 `action` 代表处理数据的类型及参数。此函数返回一个新的 `state` 。可以设置 `state` 的默认值作为 `state` 的初始值。



### action

是一个纯对象，必须包含 `type` 属性，`type` 属性用来标识处理数据的类型，还可以设置其他值用来传参。

```js
let INCREMENT = "increment"
let = action = {
  type: INCREMENT
}
```



### createStore

`createStore(reducer, initalState)` 函数接收两个参数，第一个参数是 `reducer` ，第二个是初始数据状态 `state` 的值。如果 `reducer` 中 `state` 没有设置默认值，那么就可以通过此处设置初始值。此函数返回 `store` 对象。



## 使用

```js
import { createStore } from "./redux/index";
//初始状态值
let initState = 0;
// 用来标识处理数据的方式类型
const DECREMENT = Symbol.for("decrement");
const INCREMENT = Symbol.for("increment");

// action 必须有 type 属性
// reducer 处理数据，返回新的 state
function reducer(state, action) {
  switch (action.type) {
    case INCREMENT:
      return state + 1;
    case DECREMENT:
      return state - 1;
    default:
      return state;
  }
}


// 创建 store
let store = createStore(reducer, initState);

// 订阅函数，数据更新后自动执行。返回解绑函数。
let unsubscribe = store.subscribe(() => {
  console.log("刷新", store.getState());
});

//获取 state 的值
let state = store.getState(); // store.getState() 获取state
console.log(state);

// 触发数据更新 执行 reducer 
function add() {
  store.dispatch({ type: INCREMENT });
}
setInterval(() => {
  add();
}, 1000);


// 解绑订阅的函数
setTimeout(() => {
  unsubscribe();
}, 5000);
```

组件中使用

```js
import React, { Component } from "react";
import { createStore } from "redux";

let INCREMENT = "increment";
let DECREMENT = "decrement";
let initialState = 0;

let reducer = (state, action) => {
  switch (action.type) {
    case INCREMENT:
      return state + 1;
    case DECREMENT:
      return state - 1;
    default:
      return state;
  }
};

let store = createStore(reducer, initialState);

export default class Counter extends Component {
  state = { number: store.getState() };
  componentDidMount() {
    // 订阅this.setState
    store.subscribe(() => {
      this.setState({
        number: store.getState(),
      });
    });
  }
  componentWillUnmount() {
     this.unsubscribe();
  }
  increment = () => {
    store.dispatch({ type: INCREMENT });
  };
  decrement = () => {
    store.dispatch({ type: DECREMENT });
  };
  render() {
    return (
      <div>
        <div>{this.state.number}</div>
        <button onClick={this.increment}>+</button>
        <button onClick={this.decrement}>-</button>
      </div>
    );
  }
}
```



## 手写实现

`crreateState.js`

```js
export default function createStore(reducer, initState) {
  if (typeof reducer !== "function")
    throw new Error("reducer must be a function type!");

  let state = initState;
  let subscribeFuncs = [];

  //派发
  function dispatch(action) {
    if (!isActionType(action)) throw new Error("action`s type is error!");
    if (action.type === undefined) throw new Error("action`s type is error!");
    state = reducer(state, action);
    for (let i = 0; i < subscribeFuncs.length; i++) {
      const fun = subscribeFuncs[i];
      fun();
    }
    return action;
  }
  //订阅
  function subscribe(func) {
    let isSubscribe = true;
    subscribeFuncs.push(func);
    return function () {
      if (isSubscribe) {
        // 返回取消订阅函数
        let index = subscribeFuncs.indexOf(func);
        subscribeFuncs.splice(index, 1);
        isSubscribe = false;
      }
    };
  }
  function getState() {
    return state;
  }

  dispatch({ type: "9090909" });
  return {
    dispatch,
    subscribe,
    getState,
  };
}

// 判断是不是 actino 是不是 纯对象
function isActionType(action) {
  if (typeof action !== "object" || typeof action === null) return false;
  let proto = action;
  while (Object.getPrototypeOf(proto)) {
    proto = Object.getPrototypeOf(proto);
  }
  return Object.getPrototypeOf(action) === proto;
}
```



## 判断纯对象

```js
function isActionType(action) {
  if (typeof action !== "object" || typeof action === null) return false;
  let proto = action;
  while (Object.getPrototypeOf(proto)) {
    proto = Object.getPrototypeOf(proto);
  }
  return Object.getPrototypeOf(action) === proto;
}
```



## bindActionCreators

为了方便高校的得到 `action` 我们把 `action` ，用函数去创建它，并把这些函数统一的存入一个对象。如下：

```js
let actionCreators = {
  increment(value) {
    //使用value
    return { type: INCEMENT, someProp: value };
  },
  decrement(value) {
     //使用value
    // ...
    return { type: DECEMENT };
  },
};
```

通过执行函数就可以拿到对应的 `action`。

`bindActionCreators`  的作用就是将这些创建 `action` 的函数改造为分发（`dispatch`）`action` 的函数。把上面的 `actionCreators` 变成如下的 `dispatchActions`。

使用方式

```js
let dispatchActions = bindActionsCreators(actionCreators, store.dispatch);
```

```js
let dispatchActions = {
  increment(value) {
    store.dispatch({ type: INCEMENT, someProp: value };);
  },
  decrement(value) {
    store.dispatch({ type: DECEMENT });
  },
};
```

这样我们就可以直接调用 `bindActionCreators` 中的函数直接分发 `action` 了。

实现如下：

```js
let bindActionsCreator = (actionsCreator, dispatch) => {
  return function () {
    return dispatch(actionsCreator.apply(this, arguments));
  };
};

let bindActionsCreators = (actions, dispatch) => {
  if (typeof actions === "function") {
    return bindActionsCreator(actions, dispatch);
  } else {
    let bindActions = {};
    for (const key in actions) {
      const actionsCreator = actions[key];
      bindActions[key] = bindActionsCreator(actionsCreator, dispatch);
    }
    return bindActions;
  }
};

export default bindActionsCreators;
```



## CombineReducers

大型的应用，状态操作太多，不可能把所有的状态操作行为都房子一个 `reducer` 中，放在一起太乱，不好维护。如下目录，把多个 `reducer` 写成不同的文件，最后在 `index.js` 中使用 `CombineReducers` 方法汇总。

`CombineReducers` 方法返回一个新的总的 `reducers` 函数，`reducers` 函数中包含所有的子`reducer` 函数，返回的状态值也是一个对象，键为每一个 `reducer` 传入的键名。

<img src="https://my-blog-leo.oss-cn-chengdu.aliyuncs.com/reducers.png"/>

```js
// index.js
import { combineReducers } from "redux";
import counter1 from "./counter1";
import counter2 from "./counter2";

let reducers = combineReducers1({
  counter1,
  counter2,
});

export default reducers;
```

使用的时候通过 `store.getState()` 获取到的 `state` 就是一个对象，每一个键对应一个 `reducer` 的返回值。

```js
let state = store.getState()
console.log(state) // ==> {counter1: 11, counter2: 12}
```

通过 `createStore` 设置默认值时也是通过对象的形式。

```js
let initialState = { counter1: 10, counter2: 11 }; // state 的初始值
let store = createStore(reducers, initialState);
```



### 实现

```js
function combineReducers(reducers) {
  return (state, action) => { // 返回一个新的总的 reducers 函数，其中包含所有 reducer 的执行结果。
    let newstate = {}; // 定义新状态对象。
    for (const key in reducers) {
      const reducer = reducers[key];
      newstate[key] = reducer(state[key], action);
    }
    return newstate; // 返回新状态对象
  };
}
```



## 全部源码实现

<RecoDemo :collapse="true">
  <template slot="code- index.js">
​    <<< @/docs/frontend/react/code/redux/index.js
  </template>
  <template slot="code- createStore.js">
​    <<< @/docs/frontend/react/code/redux/createStore.js
  </template>
  <template slot="code- combineReducers.js">
​    <<< @/docs/frontend/react/code/redux/combineReducers.js
  </template>
 <template slot="code- bindActionsCreators.js">
​    <<< @/docs/frontend/react/code/redux/bindActionsCreators.js
  </template>
 <template slot="code- isActionType.js">
​    <<< @/docs/frontend/react/code/redux/utils/isActionType.js
  </template>
</RecoDemo>




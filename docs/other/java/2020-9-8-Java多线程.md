---
title: "Java 多线程"
date: 2020-09-08
sidebar: 'auto'
categories:
- 其他
tags:
- Java
---



# Java 多线程

## 1. 基本概念

### 1.1 程序

是为完成特定任务、用某种语言编写的一组指令的集合。即指一段静态的代码，静态对象。 

### 1.2 进程

是程序的一次执行过程，或是正在运行的一个程序。是一个动态 的过程：有它自身的产生、存在和消亡的过程。——生命周期 

* 如：运行中的QQ，运行中的MP3播放器 
* 程序是静态的，进程是动态的 
* 进程作为资源分配的单位，系统在运行时会为每个进程分配不同的内存区域 

### 1.3 线程

进程可进一步细化为线程，是一个程序内部的一条执行路径。 

* 若一个进程同一时间并行执行多个线程，就是支持多线程的 
* 线程作为调度和执行的单位，每个线程拥有独立的运行栈和程序计数器(pc)，线程切换的开 销小 
* 一个进程中的多个线程共享相同的内存单元/内存地址空间 -> 它们从同一堆中分配对象，可以访问相同的变量和对象。这就使得线程间通信更简便、高效。但多个线程操作共享的系统资 源可能就会带来安全的隐患。

![图一](https://my-blog-leo.oss-cn-chengdu.aliyuncs.com/16.png)


## 2. 线程的创建和使用

### 2.1 Thread 类

Java语言的JVM允许程序运行多个线程，它通过 `java.lang.Thread `类来体现。 

**`Thread`类的特性**

* 每个线程都是通过某个特定`Thread`对象的`run()`方法来完成操作的，经常 把`run()`方法的主体称为线程体 
* 通过该`Thread`对象的`start()`方法来启动这个线程，而非直接调用`run()`

**构造器**

* `Thread()`：创建新的`Thread`对象 
* `Thread(String threadname)`：创建线程并指定线程实例名 
* `Thread(Runnable target)`：指定创建线程的目标对象，它实现了`Runnable`接口中的`run`方法
* `Thread(Runnable target, String name)`：创建新的`Thread`对象

**API中创建线程的两种方式**

继承`Thread`类的方式

实现`Runnable`接口的方式 

#### **方式一：继承`Thread`类**

* 定义子类继承Thread类。 
* 子类中重写Thread类中的run方法。 
* 创建Thread子类对象，即创建了线程对象。 
* 调用线程对象start方法：启动线程，调用run方法

```java
public class Demo1 {
  public static void main(String[] args) {
    //创建线程实例对象
    EvenThread e = new EvenThread();
		e.start();
    
    //匿名子类实例对象创建
    new Thread(){
      @Override
      public void run() {
        for (int i = 0; i < 100; i++) {
          if(i%2 == 0)
            System.out.println(Thread.currentThread().getName()+":"+i);
        }
      }
    }.start();
  }
}

class EvenThread extends Thread{
  @Override
  public void run() {
    for (int i = 0; i < 100; i++) {
      if(i%2 != 0)
        System.out.println(Thread.currentThread().getName()+":"+i);
    }
  }
}
```

::: warning 注意

* 如果自己手动调用`run()`方法，那么就只是普通方法，没有启动多线程模式。 
* run()方法由JVM调用，什么时候调用，执行的过程控制都有操作系统的CPU 调度决定。 
* 想要启动多线程，必须调用`start`方法。 
* 一个线程对象只能调用一次`start()`方法启动，如果重复调用了，则将抛出异常`。

:::



####  **方式二：实现`Runnable`接口** 

* 定义子类，实现`Runnable`接口。 
* 子类中重写`Runnable`接口中的`run`方法。 
* 通过`Thread`类含参构造器创建线程对象。 
* 将`Runnable`接口的子类对象作为实际参数传递给`Thread`类的构造器中。 
* 调用`Thread`类的`start`方法：开启线程，调用`Runnable`子类接口的`run`方法。

```java
public class PriorityTest {
  public static void main(String[] args) {

    RunInstance r1 = new RunInstance();
    Thread thread = new Thread(r1);
    thread.start();

    new Thread(new Runnable() {
      @Override
      public void run() {
        System.out.println("创建匿名类使用Runnable创建的线程");
      }
    }).start();
  }
}

class RunInstance implements Runnable{
  @Override
  public void run() {
    System.out.println("使用Runnable创建的线程");
  }
}
```

#### 两种方式区别

区别 

* 继承`Thread`：线程代码存放`Thread`子类`run`方法中。
* 实现`Runnable`：线程代码存在接口的子类的`run`方法。 

实现方式的好处 

* 避免了单继承的局限性 
* 多个线程可以共享同一个接口实现类的对象，非常适合多个相同线 程来处理同一份资源。

#### `Thread` 类的有关方法

* `void start()`: 启动线程，并执行对象的`run()`方法
* `run()`: 线程在被调度时执行的操作
* `String getName()`: 返回线程的名称 
* `void setName(String name)`:设置该线程名称 
* `static Thread currentThread()`: 返回当前线程。在`Thread`子类中就 是`this`，通常用于主线程和`Runnable`实现类

* `static void yield()`：线程让步 
  * 暂停当前正在执行的线程，把执行机会让给优先级相同或更高的线程 
  * 若队列中没有同优先级的线程，忽略此方法 
  * cpu 释放该线程执行权后 所有线程又竞争CPU资源
* `join()` ：主线程A中调用B的`join`方法 A就进入阻塞 B执行完成后 A再结束阻塞开始执行
  * 低优先级的线程也可以获得执行 
* `static void sleep(long millis)`：(指定时间:毫秒) 
  * 令当前活动线程在指定时间段内放弃对CPU控制,使其他线程有机会被执行,时间到后 重排队。 
  * 抛出`InterruptedException`异常 
* `stop()`: 强制线程生命期结束，不推荐使用 
* `boolean isAlive()`：返回`boolean`，判断线程是否还活着

### 2.2 线程的优先级

线程的优先级等级

* `MAX_PRIORITY：10`
* `MIN _PRIORITY：1 `
* `NORM_PRIORITY：5` 

涉及的方法 

* `getPriority()` ：返回线程优先值 
* `setPriority(int newPriority)` ：改变线程的优先级 

说明 

* 线程创建时继承父线程的优先级 
* 低优先级只是获得调度的概率低，并非一定是在高优先级线程之后才被调用

```java
public class demo2 {
  public static void main(String[] args) throws InterruptedException {
    A thread = new A();
    thread.setName("线程一");
    //设置线程优先级
    thread.setPriority(Thread.MAX_PRIORITY);
    thread.start();

    Thread.currentThread().setName("主线程 main");
    for (int i = 0; i < 100 ; i++) {
      System.out.println(i + Thread.currentThread().getName() + Thread.currentThread().getPriority());// 返回线程优先值
      if(i == 40){
        thread.join();
        System.out.println(thread.isAlive());
      }
    }


  }
}

class A extends Thread{
  @Override
  public void run() {
    for (int i = 0; i < 100; i++) {
      if(i%2==0){
        //                try {
        //                    sleep(100);
        //                } catch (InterruptedException e) {
        //                    e.printStackTrace();
        //                }
        System.out.println(Thread.currentThread().getName()+i);
      }
      if(i == 20){
        this.yield();
      }
    }
  }
}
```





## 3. 线程的生命周期

**JDK中用Thread.State类定义了线程的几种状态** 

要想实现多线程，必须在主线程中创建新的线程对象。Java语言使用Thread类 及其子类的对象来表示线程，在它的一个完整的生命周期中通常要经历如下的五 种状态： 

* 新建： 当一个Thread类或其子类的对象被声明并创建时，新生的线程对象处于新建 状态 
* 就绪：处于新建状态的线程被start()后，将进入线程队列等待CPU时间片，此时它已 具备了运行的条件，只是没分配到CPU资源 
* 运行：当就绪的线程被调度并获得CPU资源时,便进入运行状态， run()方法定义了线 程的操作和功能 
* 阻塞：在某种特殊情况下，被人为挂起或执行输入输出操作时，让出 CPU 并临时中 止自己的执行，进入阻塞状态 
* 死亡：线程完成了它的全部工作或线程被提前强制性地中止或出现异常导致结束

![图二](https://my-blog-leo.oss-cn-chengdu.aliyuncs.com/17.png) -->

## 4. 线程同步

**问题**

多线程出现了安全问题 

* 问题的原因： 当多条语句在操作同一个线程共享数据时，一个线程对多条语句只执行了一部分，还没有 执行完，另一个线程参与进来执行。导致共享数据的错误。 
* 解决办法： 对多条操作共享数据的语句，只能让一个线程都执行完，在执行过程中，其他线程不可以 参与执行。

### 4.1 Synchronized

> Java对于多线程的安全问题提供了专业的解决方式：同步机制

```java
synchronized (同步监视器){
  // 需要被同步的代码；
}
//同步监视器：俗称：锁 。任何一类的对象都可以当锁
```

`synchronized`还可以放在方法声明中，表示整个方法为同步方法。例如:

```java
public synchronized void show (String name){ …. }
```

**同步锁机制**

同步机制中的锁 在《Thinking in Java》中，是这么说的：对于并发工作，你需要某种方式来防 止两个任务访问相同的资源（其实就是共享资源竞争）。 防止这种冲突的方法 就是当资源被一个任务使用时，在其上加锁。第一个访问某项资源的任务必须 锁定这项资源，使其他任务在其被解锁之前，就无法访问它了，而在其被解锁 之时，另一个任务就可以锁定并使用它了。 

synchronized的锁是什么？

* 任意对象都可以作为同步锁。所有对象都自动含有单一的锁（监视器）。 
* 同步方法的锁：静态方法（类名.class）、非静态方法（this） 
* 同步代码块：自己指定，很多时候也是指定为this或类名.class 

::: tip 注意

必须确保使用同一个资源的多个线程共用一把锁，这个非常重要，否则就 无法保证共享资源的安全 

一个线程类中的所有静态方法共用同一把锁（类名.class），所有非静态方 法共用同一把锁（this），同步代码块（指定需谨慎）

:::

**示例**

```java
public class Test {
  public static void main(String[] args) {
    Window1 w1 = new Window1();
    Thread t1 = new Thread(w1);
    Thread t2 = new Thread(w1);
    Thread t3 = new Thread(w1);

    t1.setName("线程一");
    t2.setName("线程二");
    t3.setName("线程三");

    //线程安全问题
    t1.start();
    t2.start();
    t3.start();
  }
}

class Window1 implements Runnable{
  private int ticketsNum = 100;
  //Object object = new Object();
  @Override
  public void run() {
    while (true){
      //synchronized(object){
      synchronized(this){//使用this作为同步监视器 在这的this 唯一 就可用 不唯一就不可用
        if(ticketsNum>0){
          System.out.println(Thread.currentThread().getName()+"买票, 票号：" + ticketsNum);
          ticketsNum--;
        }else {
          break;
        }
      }
    }
  }
}
```

```java
public class Synchronization4 {
  public static void main(String[] args) {
    Window4 w1 = new Window4();
    Window4 w2 = new Window4();
    Window4 w3 = new Window4();

    w1.setName("线程一");
    w2.setName("线程二");
    w3.setName("线程三");

    //线程安全问题
    w1.start();
    w2.start();
    w3.start();
  }
}

class Window4 extends Thread{
  private static int ticketsNum = 100;

  @Override
  public void run() {
    while (true){ handle();}
  }
  
//锁的问题 t1 t2 t3 保证可以使用 要加static 同步监视器为当前类
  public static synchronized void handle(){// 同步方法 同步监视器：Window4.class 类只会加载一次
    if(ticketsNum>0){
      System.out.println(Thread.currentThread().getName()+"买票, 票号：" + ticketsNum);
      ticketsNum--;
    }
  }
}
```



### 4.2 Lock(锁)

从JDK 5.0开始，Java提供了更强大的线程同步机制——通过显式定义同 步锁对象来实现同步。同步锁使用`Lock`对象充当。 

java.util.concurrent.locks.Lock 接口是控制多个线程对共享资源进行访问的工具。锁提供了对共享资源的独占访问，每次只能有一个线程对`Lock`对象 加锁，线程开始访问共享资源之前应先获得`Lock`对象。 

`ReentrantLock` 类实现了 `Lock` ，它拥有与 `synchronized` 相同的并发性和 内存语义，在实现线程安全的控制中，比较常用的是`ReentrantLock`，可以 显式加锁、释放锁。

```java
class A{
  private final ReentrantLock lock = new ReenTrantLock();
  public void m(){
    lock.lock();
    try{
      //保证线程安全的代码;
    }
    finally{
      lock.unlock();
    }
  }
}
```

::: tip 注意

如果同步代码有异常，要将`unlock()`写入`finally`语句块

:::

```java
import java.util.concurrent.locks.ReentrantLock;
/*
* 解决线程安全方式三 Lock jdk 5.0 新增
* lock 需要手动启动同步 （lock）同时也需要手动实现结束同步（unlock）
* 优先使用顺序
* lock -》 同步代码块 -》 同步方法
* */
public class LockTest {
  public static void main(String[] args) {
    Window w = new Window();

    Thread t1 = new Thread(w);
    Thread t2 = new Thread(w);
    Thread t3 = new Thread(w);

    t1.setName("窗口1");
    t2.setName("窗口2");
    t3.setName("窗口3");

    t1.start();
    t2.start();
    t3.start();
  }
}

class Window implements Runnable{

  private int tickets = 100;

  //实例化lock
  private ReentrantLock lock = new ReentrantLock();

  @Override
  public void run() {
    while (true){
      try{
        //调用锁定方法lock（）
        lock.lock();
        if(tickets > 0){
          System.out.println(Thread.currentThread().getName() + "票号："+ tickets);
          tickets --;
        } else {
          break;
        }
      }finally {
        //调用解锁方法
        lock.unlock();
      }
    }
  }
}
```

### 4.3 synchronized 与 Lock 的对比 

* `Lock`是显式锁（手动开启和关闭锁，别忘记关闭锁），`synchronized`是隐式锁，出了作用域自动释放 
* `Lock`只有代码块锁，`synchronized`有代码块锁和方法锁 
* 使用`Lock`锁，JVM将花费较少的时间来调度线程，性能更好。并且具有 更好的扩展性（提供更多的子类）



## 5. 线程通信

`wait()` 与` notify()` 和 `notifyAll() `

* `wait(`)：令当前线程挂起并放弃CPU、同步资源并等待，使别的线程可访问并修改共享资源，而当 前线程排队等候其他线程调用`notify()`或`notifyAll()`方法唤醒，唤醒后等待重新获得对监视器的所有 权后才能继续执行。 
* `notify()`：唤醒正在排队等待同步资源的线程中优先级最高者结束等待 
* `notifyAll ()`：唤醒正在排队等待资源的所有线程结束等待. 

**这三个方法只有在`synchronized`方法或`synchronized`代码块中才能使用**，否则会报异常。 

因为这三个方法必须由锁对象调用，而任意对象都可以作为`synchronized`的同步锁， 因此这三个方法只能在`Object`类中声明。

### 5.1 wait()

* 在当前线程中调用方法： 对象名.wait() 
* 使当前线程进入等待（某对象）状态 ，直到另一线程对该对象发出 `notify` (或`notifyAll`) 为止。 
* 调用方法的必要条件：当前线程必须具有对该对象的监控权（加锁） 
* 调用此方法后，**当前线程将释放对象监控权** ，然后进入等待 
* 在当前线程被`notify`后，要重新获得监控权，然后从断点处继续代码的执行。

::: warning 注意

wait 与 sleep 不同：
*  sleep 在 ThreadPool 类中; Object 类中声明wait
*  sleep 可以在任何需要的情况下用 ；wait 只能在同步代码块或同步方法中用
*  sleep 不释放同步监视器 二 wait 会

:::

### 5.2 notify() notifyAll()

* 在当前线程中调用方法： 对象名.notify() 
* 功能：唤醒等待该对象监控权的一个/所有线程。 
* 调用方法的必要条件：当前线程必须具有对该对象的监控权（加锁）

```java
/*
 * 线程通信 交替打印 数字1-100
 *
 * 三个方法
 *
 * 必须在同步代码块中使用或同步方法中
 * wait() 阻塞 释放同步监视器 与sleep 不同 不会释放同步监视器
 * notify() 唤醒当前这个 wait的线程
 * notifyAll() 唤醒所有 wait的线程
 * 👆三个方法的调用者必须是 同步监视器
 * 这三个方法定义在object 上
 *
 * ！！！！！！！！！！！！！！！！！！
 * wait 与 sleep 不同：
 *  sleep 在 ThreadPool 类中; Object 类中声明wait
 *  sleep 可以在任何需要的情况下用 ；wait 只能在同步代码块或同步方法中用
 *  sleep 不释放同步监视器 二 wait 会
 * */
public class Communication {
  public static void main(String[] args) {
    Number n = new Number();
    Thread t1 = new Thread(n);
    Thread t2 = new Thread(n);

    t1.setName("线程1");
    t2.setName("线程2");

    t1.start();
    t2.start();
  }
}

class Number implements Runnable {
  private int num = 1;
  @Override
  public void run() {
    while (true) {
      synchronized (this){
        notify();
        if (num < 101) {
          System.out.println(Thread.currentThread().getName() + " : " + num++);
          try {
            wait(); //调用后该线程阻塞 会释放锁！！！
          } catch (InterruptedException e) {
            e.printStackTrace();
          }
        } else {
          break;
        }
      }
    }
  }
}
```



## 6. 新的线程创建方式

### 6.1 新增方式一实现Callable接口

与使用`Runnable`相比， `Callable`功能更强大些 

* 相比run()方法，可以有返回值 
* 方法可以抛出异常 
* 支持泛型的返回值 
* 需要借助`FutureTask`类，比如获取返回结果



**Future接口** 

* 可以对具体`Runnable`、`Callable`任务的执行结果进行取消、查询是 否完成、获取结果等。 
* `FutrueTas`k是`Futrue`接口的唯一的实现类 
* `FutureTask` 同时实现了`Runnabl`e, `Future`接口。它既可以作为 `Runnable`被线程执行，又可以作为`Future`得到`Callable`的返回值

```java
/*
 * 实现Callable 接口的方式创建线程
 * call 方法有返回值 可以抛出异常 支持泛型
 * */

// 1.创建callable 实现类
class NumThread implements Callable<Integer> {
  @Override
  public Integer call() throws Exception {
    int sum = 0;
    for (int i = 0; i < 100; i++) {
      sum += i;
    }
    return sum;
  }
}

public class ThreadTest {
  public static void main(String[] args) {
    //2.创建Callable实现类的对象
    NumThread n = new NumThread();

    //3.将Callable实现对象传入FutureTask构造器中的到新对象
    FutureTask<Integer> f = new FutureTask(n);

    //4. 得到新对象传入Thread   开启线程
    new Thread(f).start();

    //5. 获取返回值
    try {
      //返回 call 的返回值
      Integer sum = f.get();
      System.out.println(sum);
    } catch (Exception e) {
      e.printStackTrace();
    }
  }
}
```

### 6.2 新增方式二 使用线程池

#### 6.2.1 概述

经常创建和销毁、使用量特别大的资源，比如并发情况下的线程， 对性能影响很大。 

提前创建好多个线程，放入线程池中，使用时直接获取，使用完 放回池中。可以避免频繁创建销毁、实现重复利用。类似生活中的公共交 通工具。 

好处

* 提高响应速度（减少了创建新线程的时间） 
* 降低资源消耗（重复利用线程池中线程，不需要每次都创建） 
* 便于线程管理 
  * `corePoolSize`：核心池的大小 
  * `maximumPoolSize`：最大线程数 
  * `keepAliveTime`：线程没有任务时最多保持多长时间后会终止

#### 6.2.2 线程池相关API

JDK 5.0起提供了线程池相关API：`ExecutorService` 和` Executors `


``` java
ExecutorService//真正的线程池接口。常见子类ThreadPoolExecutor

void execute(Runnable command)//执行任务/命令，没有返回值，一般用来执行 Runnable 

Future submit(Callable task)//执行任务，有返回值，一般又来执行Callable 

void shutdown()//关闭连接池 

Executors //工具类、线程池的工厂类，用于创建并返回不同类型的线程池
Executors.newCachedThreadPool()//创建一个可根据需要创建新线程的线程池
Executors.newFixedThreadPool(n)//创建一个可重用固定线程数的线程池 
Executors.newSingleThreadExecutor()//创建一个只有一个线程的线程池
Executors.newScheduledThreadPool(n)//创建一个线程池，它可安排在给定延迟后运 行命令或者定期地执行。
```

```java
/*
*
* 线程池
*
* 属性设置
* corePoolSize 核心池大小
* maximumPoolSize 最大线程数
* keepAliveTime 没有任务时线程保留时间
* */

class Num implements Runnable{
  @Override
  public void run() {
    for (int i = 0; i < 100; i++) {
      if(i%2 == 0){
        System.out.println(i);
      }
    }
  }
}

public class ThreadPool {
  public static void main(String[] args) {
    ThreadPoolExecutor service = (ThreadPoolExecutor)Executors.newFixedThreadPool(10);

    //设置属性
    service.setCorePoolSize(15);
    //......

    service.execute(new Num());//适合用于Runnable
    //service.submit(); //适合用于Callable
    
    service.shutdown();//关闭线程池
  }
}
``` 




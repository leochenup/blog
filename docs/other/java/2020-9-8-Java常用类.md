---
title: "Java 常用类"
date: 2020-09-08
sidebar: 'auto'
categories:
- 其他
tags:
- Java
---



## Java 常用类

### 1. 字符串相关

#### 1.1 String

##### 1.1.1 概念及特点

* `String` 是一个 `final` 类不可被继承，代表不可变的字符序列

  * 体现不可变性：
    * 字符串重新复制时，会重新指定内存区域存储值，不会在原有的 `value` 的地址上进行复制
    * 对现有字符串俩接操作，也需要重新指定地址赋值
    * 修改字符串 也是一样的需要重新在一个地址上操作 ，不能对原有的进行影响

* `String` 对象的字符内容是存储在一个字符数组 `final char[] value`中的

* `String` 实现了 `Serializable`（可序列化） 接口、`Comparable` 接口

* 通过字面量方式给创建一个字符串，此时字符串值在字符串常量池中（常量池中不会存储相同内容的字符串）

  

##### 1.1.2 String 对象的创建

```java
String str = "hello";

String s1 = new String();

String s2 = new String(String original);

String s3 = new String(char[] a);

String s4 = new String(char[] a, int startIndex, int count);
```



##### 1.1.3 字符串拼接的特性

常量与常量的拼接结果在常量池。且常量池中不会存在相同内容的常量。 只要其中有一个是变量，结果就在堆中。如果拼接的结果调用 `intern()` 方法，返回值就在常量池中。代码如下

```java
String s1 = "java";
String s2 = "hadoop";
String s3 = "javahadoop";
String s4 = s1 + s2;
String s5 = s1 + "hadoop";
String s6 = "java" + s2;
String S7 = "java" + "hadoop";
String s8 = s5.intern()

System.out.println(s3 == s4);//false
System.out.println(s3 == s5);//false
System.out.println(s4 == s5 );//false
System.out.println(s5 == s6);//false
System.out.println(s7 == s3);// true
System.out.println(s3 == s8);// true
```



##### 1.1.4 String 常用方法

* `int length()`：返回字符串的长度：` return value.length`
* `char charAt(int index)`： 返回某索引处的字符 `return value[index]` 
*  `boolean isEmpty()`：判断是否是空字符串：`return value.length == 0` 
*  `String toLowerCase()`：使用默认语言环境，将 `String` 中的所有字符转换为小写 
*  `String toUpperCase()`：使用默认语言环境，将 `String` 中的所有字符转换为大写 
*  `String trim()`：返回字符串的副本，忽略前导空白和尾部空白 
*  `boolean equals(Object obj)`：比较字符串的内容是否相同 
*  `boolean equalsIgnoreCase(String anotherString)`：与 `equals` 方法类似，**忽略大小写** 
*  `String concat(String str)`：将指定字符串连接到此字符串的结尾。 等价于用“+” 
*  `int compareTo(String anotherString)`：比较两个字符串的大小 
*  `String substring(int beginIndex)`：返回一个新的字符串，它是此字符串的从`beginIndex` 开始截取到最后的一个子字符串。 
*  `String substring(int beginIndex, int endIndex)` ：返回一个新字符串，它是此字 符串从`beginIndex` 开始截取到 `endIndex` (不包含)的一个子字符串。
* `boolean endsWith(String suffix)`：测试此字符串是否以指定的后缀结束 
*  `boolean startsWith(String prefix)`：测试此字符串是否以指定的前缀开始 
*  `boolean startsWith(String prefix, int toffset)`：测试此字符串从指定索引开始的 子字符串是否以指定前缀开始
* `boolean contains(CharSequence s)`：当且仅当此字符串包含指定的 char 值序列 时，返回 true 
*  `int indexOf(String str)`：返回指定子字符串在此字符串中第一次出现处的索引 
*  `int indexOf(String str, int fromIndex)`：返回指定子字符串在此字符串中第一次出 现处的索引，从指定的索引开始 
*  `int lastIndexOf(String str)`：返回指定子字符串在此字符串中最右边出现处的索引 
*  `int lastIndexOf(String str, int fromIndex)`：返回指定子字符串在此字符串中最后 一次出现处的索引，从指定的索引开始反向搜索 注：`indexOf`和`lastIndexOf`方法如果未找到都是返回-1
* `String replace(char oldChar, char newChar)`：返回一个新的字符串，它是 通过用 newChar 替换此字符串中出现的所有 oldChar 得到的。 
*  `String replace(CharSequence target, CharSequence replacement)`：使 用指定的字面值替换序列替换此字符串所有匹配字面值目标序列的子字符串。 
*  `String replaceAll(String regex, String replacement)` ： 使 用 给 定 的 `replacement` 替换此字符串**所有**匹配给定的正则表达式的子字符串。 
*  `String replaceFirst(String regex, String replacement)` ： 使 用 给 定 的 `replacement` 替换此字符串匹配给定的正则表达式的**第一个**子字符串。 
*  `boolean matches(String regex)`：告知此字符串是否匹配给定的正则表达式。 
*  `String[] split(String regex)`：根据给定正则表达式的匹配拆分此字符串。 
*  `String[] split(String regex, int limit)`：根据匹配给定的正则表达式来拆分此 字符串，最多不超过limit个，如果超过了，剩下的全部都放到最后一个元素中。



**问题**

* `String s2 = new String("abc")` 在内存中创建了几个对象？

  两个：一个是 在 堆空间中的 `new`的结构，另一个是` char[]` 对应的常量池中的数据：`"abc"`

![图1](https://my-blog-leo.oss-cn-chengdu.aliyuncs.com/1.1.png)


#### 1.2 StringBuffer、StringBuilder

##### 1.2.1 StringBuffer

###### 1.2.1.1 概述

* `java.lang.StringBuffer` 代表可变的字符序列，`JDK1.0` 中声明，可以对字符 串内容进行增删，此时不会产生新的对象。
* 很多方法与 `String` 相同。
* 作为参数传递时，方法内部可以改变值。

```java
abstract class AbstractStringBuilder implements Appendable, CharSequence {
  	/**
     * The value is used for character storage.
     */
  char[] value; // value 没有 final 声明，value 可以不断扩展。 

  	/**
     * The count is the number of characters used.
     */
  int count;
  ....
```

* `StringBuffer` 类不同于 `String`，其对象必须使用构造器生成。有三个构造器： 

  * `StringBuffer()`：初始容量为16的字符串缓冲区 

  * `StringBuffer(int size)`：构造指定容量的字符串缓冲区 

  * `StringBuffer(String str)`：将内容初始化为指定字符串内容

    

###### 1.2.1.2 StringBuffer 常用方法

* `StringBuffer append(xxx)`：提供了很多的 `append()`方法，用于进行字符串拼接
*  `StringBuffer delete(int start,int end)`：删除指定位置的内容 
* `StringBuffer replace(int start, int end, String str)`：把 `[start,end)` 位置替换为 `str `
* `StringBuffer insert(int offset, xxx)`：在指定位置插入xxx 
* `StringBuffer reverse()` ：把当前字符序列逆转

::: warning 注意

 上述方法支持链式方法 

:::

* `public int indexOf(String str)`  返回指定字符串在原字符串中的位置
* `public String substring(int start,int end)` 截取字符串
* `public int length()` 返回字符串长度
* `public char charAt(int n )`  返回指定位置的字符
* `public void setCharAt(int n ,char ch)` 设置指定位置的字符

##### 1.2.2 StringBuilder

######  概述

* `StringBuilder` 和 `StringBuffer` 非常类似，均代表可变的字符序列，而且 提供相关功能的方法也一样

######  对比String、StringBuffer、StringBuilder

* `String(JDK1.0)`：不可变字符序列 
* `StringBuffer(JDK1.0)`：可变字符序列、效率低、线程安全 
* `StringBuilder(JDK 5.0)`：可变字符序列、效率高、线程不安全 



**问题**

```java
String str = null;
StringBuffer sb = new StringBuffer();
sb.append(str);

System.out.println(sb.length());//4
System.out.println(sb);//"null"

StringBuffer sb1 = new StringBuffer(str);// 抛出异常
System.out.println(sb1);//
```



### 2. 时间日期API

![图2](https://my-blog-leo.oss-cn-chengdu.aliyuncs.com/2.png)

#### 2.1 System 静态方法

* `System`类提供的`public static long currentTimeMillis()`用来返回当前时 间与1970年1月1日0时0分0秒之间以毫秒为单位的时间差（时间戳）。  此方法适于计算时间差。 

```java
 long t = System.currentTimeMillis();
 System.out.println(t);
```

::: warning 注意

计算世界时间的主要标准有：

* UTC(Coordinated Universal Time) 
* GMT(Greenwich Mean Time) 
* CST(Central Standard Time)

:::



#### 2.2 Date 

##### 2.2.1 java.util.Date

###### 两个构造器使用

* `new Date()`
* `new Date(long milli)`

```java
Date d1 = new Date();
System.out.println(d1.`toString());
//Sun Sep 06 14:46:11 CST 2020

Date d2 = new Date(1599374947872);
System.out.println(d1.`toString());
//Sun Sep 06 14:46:11 CST 2020
```

###### 两个方法的使用

* `toString()` 获取具体时间 （如：Sun Sep 06 14:46:11 CST 2020）
* `getTime()` 获取时间戳

```java
Date d1 = new Date();
System.out.println(d1.getTime());
//1599374947872
```

##### 2.2.1 java.sql.Date

* 数据库中日期类型

```java
java.sql.Date d2 = new java.sql.Date(1599374947872l);
System.out.println(d2.toString());
//2020-09-06
```

* `sql.Date` 转换为 `util.Date` 对象

```java
Date d1 = new Date();
java.sql.Date d2 =new java.sql.Date(d1.getTime());
```



#### 2.3 Calender 

* `Calendar`是一个抽象基类，主用用于完成日期字段之间相互操作的功能。 
*  获取`Calendar`实例的方法 
  * 使用`Calendar.getInstance()`方法 
  * 调用它的子类`GregorianCalendar`的构造器。 
*  一个`Calendar`的实例是系统时间的抽象表示，通过`get(int field)`方法来取得想要的时间信息。比如`YEAR`、`MONTH`、`DAY_OF_WEEK`、`HOUR_OF_DAY `、 `MINUTE`、`SECOND`、`WEEK_OF_YEAR`、`WEEK_OF_MONTH`....
  * `public void set(int field,int value) `
  * `public void add(int field,int amount) `
  * `public final Date getTime() `
  * `public final void setTime(Date date)`

::: tip 注意 

 获取月份时：一月是0，二月是1，以此类推，12月是11 

 获取星期时：周日是1，周一是2 ， 。。。。周六是7

:::

```java
Calendar calendar = Calendar.getInstance();
// 从一个 Calendar 对象中获取 Date 对象
Date date = calendar.getTime();
// 使用给定的 Date 设置此 Calendar 的时间
date = new Date(234234235235L);
calendar.setTime(date);
calendar.set(Calendar.DAY_OF_MONTH, 8);
System.out.println("当前时间日设置为8天后,时间是:" + calendar.getTime());
calendar.add(Calendar.HOUR, 2);
System.out.println("当前时间加2小时后,时间是:" + calendar.getTime());
calendar.add(Calendar.MONTH, -2);
System.out.println("当前日期减2个月后,时间是:" + calendar.getTime());
```



#### 2.4 SimpleDateFormat 

* 格式化
* 解析

```java
SimpleDateFormat sf = new SimpleDateFormat();
//格式化
Date d = new Date();
String  format = sf.format(d);
System.out.println(format);//20-9-6 下午7:27
//解析
String str = "20-9-6 下午7:21";
//解析成时间对象
Date d1 = sf.parse(str);
System.out.println(d1);//Sun Sep 06 19:21:00 CST 2020

//*********************
SimpleDateFormat sdf = new SimpleDateFormat("YYYY-MM-dd hh:mm:ss");
String d2 = sdf.format(d);
System.out.println(d2); //2020-09-06 07:27:38
//解析成时间对象 参数必须符合格式 YYYY-MM-DD hh:mm:ss格式（构造器指定的格式）
Date d3 = sdf.parse("2020-09-06 07:27:38");
```



#### 2.5 LocalDate、LocalDate、LocalDateTime

**旧的时间处理类的问题**

如果我们可以跟别人说：“我们在1502643933071见面，别晚了！”那么就再简单不 过了。但是我们希望时间与昼夜和四季有关，于是事情就变复杂了。JDK 1.0中包含了 一个`java.util.Date`类，但是它的大多数方法已经在`JDK 1.1`引入`Calenda`r类之后被弃用 了。而`Calendar`并不比`Date`好多少。它们面临的问题是： 

* 可变性：像日期和时间这样的类应该是不可变的。 
* 偏移性：`Date`中的年份是从1900开始的，而月份都从0开始。 
* 格式化：格式化只对`Date`有用，`Calendar`则不行。 此外，它们也不是线程安全的；不能处理闰秒等。

**新的时间API的引入**

* 第三次引入的API是成功的，并且`Java 8`中引入的`java.time API` 已经纠正了 过去的缺陷，将来很长一段时间内它都会为我们服务。 
*  Java 8 吸收了` Joda-Time` 的精华，以一个新的开始为 `Java` 创建优秀的` API`。 新的` java.time` 中包含了所有关于本地日期（`LocalDate`）、本地时间 （`LocalTime`）、本地日期时间（`LocalDateTime`）、时区（`ZonedDateTime`） 和持续时间（`Duration`）的类。历史悠久的 `Date `类新增了` toInstant()` 方法， 用于把 `Date` 转换成新的表示形式。这些新增的本地化时间日期 `API` 大大简 化了日期时间和本地化的管理。

**新的时间API**

* **`java.time` – 包含值对象的基础包** 
* `java.time.chrono` – 提供对不同的日历系统的访问 
* **`java.time.format` – 格式化和解析时间和日期**
* `java.time.temporal` – 包括底层框架和扩展特性 
* `java.time.zone` – 包含时区支持的类

##### 2.5.1 概述

* `LocalDate`、`LocalTime`、`LocalDateTime` 类是其中较重要的几个类，它们的实例 是不可变的对象，分别表示使用 `ISO-8601`日历系统的日期、时间、日期和时间。 它们提供了简单的本地日期或时间，并不包含当前的时间信息，也不包含与时区相关的信息。 
  * `LocalDate`代表`IOS`格式（`yyyy-MM-dd`）的日期,可以存储 生日、纪念日等日期。 
  * `LocalTime`表示一个时间，而不是日期。 
  * `LocalDateTime`是用来表示日期和时间的，**这是一个最常用的类之一**。 

::: warning 注意

`ISO-8601`日历系统是国际标准化组织制定的现代公民的日期和时间的表示 法，也就是公历。

:::

##### 2.5.2 常用方法

| 方法                                                         | 描述                                                         |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| `now() / now(ZoneId zone)`                                   | 静态方法，根据当前时间创建对象/指定时区的对象                |
| `of()`                                                       | 静态方法，根据指定日期/时间创建对象                          |
| `getDayOfMonth()/getDayOfYear()`                             | 获得月份天数(1-31) /获得年份天数(1-366)                      |
| `getDayOfWeek()`                                             | 获得星期几(返回一个 DayOfWeek 枚举值)                        |
| `getMonth()`                                                 | 获得月份, 返回一个 Month 枚举值                              |
| `getMonthValue() / getYear()`                                | 获得月份(1-12) /获得年份                                     |
| `getHour()/getMinute()/getSecond()`                          | 获得当前对象对应的小时、分钟、秒                             |
| `withDayOfMonth()/withDayOfYear()/ withMonth()/withYear()`   | 将月份天数、年份天数、月份、年份修改为指定的值并返回新的对象 |
| `plusDays(), plusWeeks(), plusMonths(), plusYears(),plusHours()` | 向当前对象添加几天、几周、几个月、几年、几小时               |
| `minusMonths() / minusWeeks()/ minusDays()/minusYears()/minusHours()` | 从当前对象减去几月、几周、几天、几年、几小时                 |

```java
LocalDate localDate = LocalDate.now();
LocalTime localTime = LocalTime.now();
LocalDateTime localDateTime = LocalDateTime.now();

System.out.println(localDate);//2020-09-06
System.out.println(localTime);//20:09:59.504
System.out.println(localDateTime);//2020-09-06T20:09:59.504

//不包括偏移量 年月日时分秒
LocalDateTime d = localDateTime.of(2020,10,5,6,30,30);


//修改后不影响原来的值
LocalDateTime d2 = localDateTime.withDayOfMonth(22);
System.out.println(d2);//2020-09-22T20:18:48.048
System.out.println(localDateTime);//2020-09-06T20:18:48.048
```



#### 2.6 Instant

##### 2.6.1 概述

* `Instant`：时间线上的一个瞬时点。 这可能被用来记录应用程序中的事件时间 戳。 
* 在处理时间和日期的时候，我们通常会想到年,月,日,时,分,秒。然而，这只是 时间的一个模型，是面向人类的。第二种通用模型是面向机器的，或者说是连 续的。在此模型中，时间线中的一个点表示为一个很大的数，这有利于计算机 处理。在UNIX中，这个数从1970年开始，以秒为的单位；同样的，在Java中， 也是从1970年开始，但以毫秒为单位。 
* `java.time`包通过值类型`Instant`提供机器视图，不提供处理人类意义上的时间 单位。`Instant`表示时间线上的一点，而不需要任何上下文信息，例如，时区。 概念上讲，它只是简单的表示自1970年1月1日0时0分0秒（UTC）开始的秒 数。因为`java.time`包是基于纳秒计算的，所以`Instant`的精度可以达到纳秒级。 
*  (1 ns = 10^-9 s) 1秒 = 1000毫秒 =10^6微秒=10^9纳秒

##### 2.6.2 常用方法

| 方法                            | 描述                                                         |
| ------------------------------- | ------------------------------------------------------------ |
| `now()`                         | 静态方法，返回默认`UTC`时区的`Instant`类的对象               |
| `ofEpochMilli(long epochMilli)` | 静态方法，返回在`1970-01-01 00:00:00`基础上加上指定毫秒 数之后的`Instant`类的对象 |
| `atOffset(ZoneOffset offset)`   | 结合即时的偏移来创建一个 `OffsetDateTime`                    |
| `toEpochMilli()`                | 返回`1970-01-01 00:00:00`到当前时间的毫秒数，即为时间戳(`long`) |

```java
//now() 获取本初子午线的时间
Instant instant = Instant.now();
//时区不同 时间不对
System.out.println(instant);

//设置偏移时间 得到正确的偏移时间
OffsetDateTime offsetDateTime = instant.atOffset(ZoneOffset.ofHours(8));
System.out.println(offsetDateTime);

//返回`1970-01-01 00:00:00`到当前时间的毫秒数，即为时间戳(`long`)
long milli = instant.toEpochMilli();
System.out.println(milli);

//静态方法，返回在`1970-01-01 00:00:00`基础上加上指定毫秒 数之后的`Instant`类的对象
Instant instant1 = instant.ofEpochMilli(1550475314878l);
System.out.println(instant1);
```



#### 2.7 DateTimeFormatter

##### 2.7.1 概述

`java.time.format.DateTimeFormatter` 类：该类提供了三种格式化方法： 

* 预定义的标准格式。

  如：` ISO_LOCAL_DATE_TIME;` ` ISO_LOCAL_DATE;` `ISO_LOCAL_TIME` 

* 本地化相关的格式。

  如：`ofLocalizedDateTime( FormatStyle.LONG  ) `

* 自定义的格式。

  如：`ofPattern(“yyyy-MM-dd hh:mm:ss”)`

##### 2.7.2 常用方法

| 方法                         | 描述                                                         |
| ---------------------------- | ------------------------------------------------------------ |
| `ofPattern(String pattern)`  | 静态方法 ， 返 回 一 个 指 定 字 符 串 格 式 的` DateTimeFormatter` |
| `format(TemporalAccessor t)` | 格式化一个日期、时间，返回字符串                             |
| parse(TemporalAccessor t)`   | 将指定格式的字符序列解析为一个日期、时间                     |

```java
// 预定义的 格式化 模式 ISO_LOCAL_DATE_TIME
DateTimeFormatter dateTimeFormatter = DateTimeFormatter.ISO_LOCAL_DATE_TIME;
LocalDateTime localDateTime = LocalDateTime.now();
String dateTimeF = dateTimeFormatter.format(localDateTime);
System.out.println(dateTimeF);//2020-09-06T21:04:47.41

//解析日期字符串 f返回时间对象
TemporalAccessor d =  dateTimeFormatter.parse("2020-09-06T20:47:25.247");
System.out.println(d);//{},ISO resolved to 2020-09-06T20:47:25.247

//本地化相关的格式化
// 本地化相关的格式 ofLocalizedDateTime
// 支持参数 FormatStyle.LONG /FormatStyle.MEDIUM /FormatStyle.SHORT
DateTimeFormatter dateTimeFormatter1 = DateTimeFormatter.ofLocalizedDateTime(FormatStyle.SHORT);
String d1 = dateTimeFormatter1.format(localDateTime);
System.out.println(d1);//20-9-6 下午9:04
//本地化相关的格式 ofLocalizedDate
// 支持参数 FormatStyle.FULL /FormatStyle.LONG /FormatStyle.MEDIUM /FormatStyle.SHORT
DateTimeFormatter dateTimeFormatter2 = DateTimeFormatter.ofLocalizedDate(FormatStyle.FULL);
String d2 = dateTimeFormatter2.format(localDateTime);
System.out.println(d2);//2020年9月6日 星期日

//方式三 自定义格式
DateTimeFormatter dateTimeFormatter3 = DateTimeFormatter.ofPattern("YYYY-MM-dd hh:mm:ss");
String format = dateTimeFormatter3.format(localDateTime);
System.out.println(format);//2020-09-06 09:08:10
//解析字符串 返回时间对象
TemporalAccessor parse = dateTimeFormatter3.parse(format);
System.out.println(parse);//{MicroOfSecond=0, WeekBasedYear[WeekFields[SUNDAY,1]]=2020, MonthOfYear=9, MinuteOfHour=9, MilliOfSecond=0, SecondOfMinute=23, HourOfAmPm=9, DayOfMonth=6, NanoOfSecond=0},ISO
```

### 3 java 比较器

#### 3.1 java.lang.Comparable 接口

* `Comparable`接口强行对实现它的每个类的对象进行整体排序。这种排序被称 为类的自然排序。 
* 实现 `Comparable` 的类必须实现 `compareTo(Object obj)` 方法，两个对象即 通过 `compareTo(Object obj)` 方法的返回值来比较大小。如果当前对象`this`大于形参对象obj，则返回正整数，如果当前对象`this`小于形参对象`obj`，则返回 负整数，如果当前对象`this`等于形参对象`obj`，则返回零。 
* 实现`Comparable`接口的对象列表（和数组）可以通过 `Collections.sort` 或 `Arrays.sort`进行自动排序。实现此接口的对象可以用作有序映射中的键或有序集合中的元素，无需指定比较器。 

```java
// String 包装类 等实现了 Comparable 接口 重写了 compareTo 方法 从而比较对象大小。
String [] arr = new String[]{"AA","CC","B","K","KK","GG"};
Arrays.sort(arr);
System.out.println(Arrays.toString(arr)); //[AA, B, CC, GG, K, KK]
```

*  对于类` C` 的每一个` e1` 和` e2` 来说，当且仅当 `e1.compareTo(e2) == 0` 与 `e1.equals(e2)` 具有相同的 `boolean` 值时，类` C `的自然排序才叫做与 `equals` 一致。建议（虽然不是必需的）最好使自然排序与 `equals` 一致。

* `Comparable` 的典型实现：(默认都是从小到大排列的) 
  * `String`：按照字符串中字符的`Unicode`值进行比较 
  * `Character`：按照字符的`Unicode`值来进行比较 
  * 数值类型对应的包装类以及`BigInteger`、`BigDecimal`：按照它们对应的数值 大小进行比
  * `Boolean`：`true` 对应的包装类实例大于 `false` 对应的包装类实例 
  * `Date`、`Time`等：后面的日期时间比前面的日期时间大

**自定义对象比较大小**

```java
//实现 Comparable 接口 重写 comparaTo 
public class Goods implements Comparable{
    private String name;
    private double price;

    .......

    @Override
    public String toString() {
        return "Goods{" +
                "name='" + name + '\'' +
                ", price=" + price +
                '}';
    }

  	// 重写 comparaTo
    @Override
    public int compareTo(Object o) {
        if(o instanceof Goods){
            Goods goods = (Goods)o;
            if(goods.price < this.price){
                return 1;
            } else if(goods.price == this.price){
                return 0;
            } else {
                return -1;
            }
        }
        throw new RuntimeException("传入的参数类型错误");
    }
}
```

```java
@Test
public void test2(){
  Goods[] arr = new Goods[]{new Goods("手机1",10.0),
                            new Goods("手机2",19.0),
                            new Goods("手机3",11.0),
                            new Goods("手机4",110.0),
                            new Goods("手机5",65.0),
                            new Goods("手机6",13.0)};

  Arrays.sort(arr);
  System.out.println(Arrays.toString(arr));
}

// 排序结果 按手机价格从小到大 ：[Goods{name='手机1', price=10.0}, Goods{name='手机3', price=11.0}, Goods{name='手机6', price=13.0}, Goods{name='手机2', price=19.0}, Goods{name='手机5', price=65.0}, Goods{name='手机4', price=110.0}]

```

#### 3.2 java.util.Comparator 接口

* 当元素的类型没有实现`java.lang.Comparable`接口而又不方便修改代码， 或者实现了`java.lang.Comparable`接口的排序规则不适合当前的操作，那么可以考虑使用 `Comparator` 的对象来排序，强行对多个对象进行整体排序的比较。 
* 重写`compare(Object o1,Object o2)`方法，比较`o1`和`o2`的大小：如果方法返 回正整数，则表示`o1`大于`o2`；如果返回0，表示相等；返回负整数，表示 `o1`小于`o2`。 
*  可以将` Comparator` 传递给 `sort` 方法（如 `Collections.sort `或 `Arrays.sort`）， 从而允许在排序顺序上实现精确控制。 
* 还可以使用 `Comparator` 来控制某些数据结构（如有序 set或有序映射）的顺序，或者为那些没有自然顺序的对象` collection` 提供排序。

**例子**

```java
String [] arr = new String[]{"AA","CC","B","K","KK","GG"};
Arrays.sort(arr, new Comparator<String>() {
  @Override
  public int compare(String o1, String o2) {
    //从大到小排
    return -o1.compareTo(o2);
  }
});

System.out.println(Arrays.toString(arr));//[KK, K, GG, CC, B, AA]
```

### 4 System 类

* `System`类代表系统，系统级的很多属性和控制方法都放置在该类的内部。 该类位于`java.lang`包。 
*  由于该类的构造器是`private`的，所以无法创建该类的对象，也就是无法实 例化该类。其内部的成员变量和成员方法都是`static`的，所以也可以很方便 的进行调用。 
*  成员变量 
  * ` System`类内部包含`in`、`out`和`err`三个成员变量，分别代表标准输入流 (键盘输入)，标准输出流(显示器)和标准错误输出流(显示器)。 
* 成员方法 
  *  `native long currentTimeMillis()`： 该方法的作用是返回当前的计算机时间，时间的表达格式为当前计算机时 间和GMT时间(格林威治时间)1970年1月1号0时0分0秒所差的毫秒数。 
  * `void exit(int status)`： 该方法的作用是退出程序。其中`status`的值为0代表正常退出，非零代表 异常退出。使用该方法可以在图形界面编程中实现程序的退出功能等。
  * ` void gc()`： 该方法的作用是请求系统进行垃圾回收。至于系统是否立刻回收，则 取决于系统中垃圾回收算法的实现以及系统执行时的情况。 
  * `String getProperty(String key)`： 该方法的作用是获得系统中属性名为`key`的属性对应的值。系统中常见 的属性名以及属性的作用如下表所示：

| 属性名       | 说明                  |
| ------------ | --------------------- |
| java.version | Java 运行时环境的版本 |
| java.home    | Java安装目录          |
| os.name      | 操作系统名称          |
| os.version   | 操作系统版本          |
| user.home    | 用户主目录            |
| user.name    | 用户的账户名          |
| user.dir     | 用户当前工作目录      |

```java
String javaVersion = System.getProperty("java.version");
System.out.println("java的version:" + javaVersion);
String javaHome = System.getProperty("java.home");
System.out.println("java的home:" + javaHome);
String osName = System.getProperty("os.name");
System.out.println("os的name:" + osName);
String osVersion = System.getProperty("os.version");
System.out.println("os的version:" + osVersion);
String userName = System.getProperty("user.name");
System.out.println("user的name:" + userName);
String userHome = System.getProperty("user.home");
System.out.println("user的home:" + userHome);
String userDir = System.getProperty("user.dir");
System.out.println("user的dir:" + userDir);
```



### 5 Math 类

`java.lang.Math`提供了一系列静态方法用于科学计算。其方法的参数和返回 值类型一般为`double`型。 

`abs `绝对值 

`acos,asin,atan,cos,sin,tan` 三角函数 

`sqrt` 平方根 

`pow(double a,doble b)` a的b次幂 

`log` 自然对数 

`exp e`为底指数 

`max(double a,double b)`

` min(double a,double b)`

 `random() `返回0.0到1.0的随机数

 `long round(double a)` `double`型数据a转换为long型（四舍五入） 

`toDegrees(double angrad)` 弧度—>角度 `toRadians(double angdeg)` 角度—>弧度



### 6 BigInteger与BigDecimal

#### 6.1 BigInteger 概述

* `Integer`类作为`int`的包装类，能存储的最大整型值为2^(31)-1，`Long`类也是有限的， 最大为2^(63)-1。如果要表示再大的整数，不管是基本数据类型还是他们的包装类 都无能为力，更不用说进行运算了。 
* ` java.math`包的`BigInteger`可以表示不可变的任意精度的整数。`BigInteger` 提供 所有 `Java` 的基本整数操作符的对应物，并提供 `java.lang.Math` 的所有相关方法。 另外，`BigInteger` 还提供以下运算：模算术、GCD 计算、质数测试、素数生成、 位操作以及一些其他操作。 
*  构造器  `BigInteger(String val)`：根据字符串构建`BigInteger`对象

#### 6.2 BigInteger 常用方法 

* `public BigInteger abs()`：返回此 `BigInteger` 的绝对值的 `BigInteger`。 
* `BigInteger add(BigInteger val)` ：返回其值为 `(this + val)` 的 `BigInteger` 
* `BigInteger subtract(BigInteger val)` ：返回其值为 `(this - val)` 的 `BigInteger` 
* `BigInteger multiply(BigInteger val) `：返回其值为 `(this * val) `的 `BigInteger` 
* `BigInteger divide(BigInteger val)` ：返回其值为 `(this / val) `的 `BigInteger`。整数相除只保留整数部分。 
* `BigInteger remainder(BigInteger val)` ：返回其值为 `(this % val)` 的 `BigInteger`。 
* `BigInteger[] divideAndRemainder(BigInteger val)`：返回包含 `(this / val)` 后跟 (`this % val) `的两个 `BigInteger` 的数组。 
* `BigInteger pow(int exponent)` ：返回其值为 `(this^(exponent))` 的` BigInteger`。



### 6.3 BigDecimal 概述

* 一般的`Float`类和`Double`类可以用来做科学计算或工程计算，但在商业计算中， 要求数字精度比较高，故用到`java.math.BigDecimal`类。 
* `BigDecimal`类支持不可变的、任意精度的有符号十进制定点数。 
* 构造器 
  * `public BigDecimal(double val)`  
  * `public BigDecimal(String val)` 

#### 6.4 BigDecimal 常用方法 

* 常用方法
  * ` public BigDecimal add(BigDecimal augend)` 
  * `public BigDecimal subtract(BigDecimal subtrahend)` 
  * `public BigDecimal multiply(BigDecimal multiplicand)` 
  * `public BigDecimal divide(BigDecimal divisor, int scale, int roundingMode)`

```java
public void testBigInteger() {
  BigInteger bi = new BigInteger("12433241123");
  BigDecimal bd = new BigDecimal("12435.351");
  BigDecimal bd2 = new BigDecimal("11");
  System.out.println(bi);
  // System.out.println(bd.divide(bd2));
 
  System.out.println(bd.divide(bd2, BigDecimal.ROUND_HALF_UP)); //四舍五入
  System.out.println(bd.divide(bd2, 15, BigDecimal.ROUND_HALF_UP));//保留15位
}
```

